#!/bin/bash
#	Backup function library for Backup Script 
#
#	Version: 0.5

# backup (  )
# The main backup function. Tass!
function backup() {
	
	if [[ ! $(ls -A $CONF_DIR) ]]; then
		echo ""
		echo "No host file specified in '$CONF_DIR'"
		echo "Stopping backup"
		echo ""
		exit
	fi

	if [ $VERBOSE -eq 1 ]; then
	  log "Backup local disk: $BACKUP_DIR" 1 1
		log "Backup local conf: $CONF_DIR" 1 1
		log "Log file         : $LOG" 1 1
	
		log "Hosts:"
		for host in `ls $CONF_DIR`
		do
		  #Parsing the various hosts, ignore the template file plz
		  if [ $host == 'template.tpl' ]; then
		    continue
	    fi
		  test_conf_dir $host
			log "$host" "" 1
		done
		
		echo -n "Startin backup"
		backup_delay $DELAY 1
	else
		backup_delay $DELAY 0
	fi

	for host in `ls $CONF_DIR`
	do
	  #Parsing the various hosts, ignore the template file plz
	  if [ $host == 'template.tpl' ]; then
	    continue
    fi

	  test_conf_dir $host #test if both per host conf files exists
	  . ${CONF_DIR}/${host}/host.conf #then source one of them
	  if [ $DEBUG -eq 1 ]; then
  	  log "Using $host configuration" "" 1
	  fi
	  
	  if ${servconf[0]}; then #if remote
  	  user="${servconf[1]}@" #set the proper username
	  else #if local
	    user="" #no username needed
	    # For remotly mounted sshfs file systems we'll
	    #+have an ad hoc username from host.conf
    fi
	  
		if [ $VERBOSE -eq 1 ]; then
			log "Inizio Backup per: $host\n" 1 1
		fi
		
		##STARTS DEBUG ONLY TASKS
		if [ ! $DEBUG -eq 1 ]; then
			dest_dir $host
		else
		  if ${servconf[0]}; then #if remote
		    log "TESTING $host" "" 1
			  log "rdiff-backup --print-statistics --verbosity $RDIFF_VERBOSITY --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf --exclude / ${user}${host}::/ ${BACKUP_DIR}/${host}" 1 1
			  logcmd "rdiff-backup --test-server ${user}${host}::/" 1 1
		  else #if local
        if ${servconf[3]}; then #if a remotely mounted sshfs filesystem
          mount_sshfs ${user}${host}::/ ${servconf[2]}
        fi
        log "TESTING mountpoint /mnt/$host" "" 1
        mountpoint ${servconf[2]} > /dev/null
        if [[ $? != 0 ]]; then
          log "ERROR: mount of the remote filesystem went bad; problem probably genereted remotly. Aborting" "" 1
	      fi
      fi
		fi
		##END DEBUG ONLY TASKS
		
		##START SERIUS BACKUP
		if [ ! $DEBUG -eq 1 ]; then
		  #If verbose AND remote
			if [ $VERBOSE -eq 1 ] && ${servconf[0]}; then
				logcmd "rdiff-backup --print-statistics --verbosity $RDIFF_VERBOSITY --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf --exclude / ${user}${host}::/ ${BACKUP_DIR}/${host}" 1 1
				logcmd "rdiff-backup --force --remove-older-than ${RETENTION} ${BACKUP_DIR}/${host}" "" 1
			#else if verbose AND local
			elif [ $VERBOSE -eq 1 ] && ! ${servconf[0]}; then
			  # If my dir is a sshfsmounted dir than handle mount
			  #+operations with the proper function
			  if ${servconf[3]}; then
          if ! mount_sshfs; then continue; fi 
        fi
			  logcmd "rdiff-backup --print-statistics --verbosity $RDIFF_VERBOSITY --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf ${servconf[2]} ${BACKUP_DIR}/${host}" 1 1
				logcmd "rdiff-backup --force --remove-older-than ${RETENTION} ${BACKUP_DIR}/${host}" "" 1
        
		  else # else if local but NOT verbose
			  if ${servconf[0]}; then #if remote
				  logcmd "rdiff-backup --verbosity $RDIFF_VERBOSITY --print-statistics --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf --exclude / ${user}${host}::/ ${BACKUP_DIR}/${host}" 1
				  logcmd "rdiff-backup --force --remove-older-than ${RETENTION} ${BACKUP_DIR}/${host}" 1
			  else #if local
			    if ${servconf[3]}; then
            if ! mount_sshfs; then continue; fi
          fi
			    logcmd "rdiff-backup --verbosity $RDIFF_VERBOSITY --print-statistics --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf ${servconf[2]} ${BACKUP_DIR}/${host}" 1
				  logcmd "rdiff-backup --force --remove-older-than ${RETENTION} ${BACKUP_DIR}/${host}" 1
			  fi
			fi
		fi
		
		# If we have $mounted true, so we have to unmount the dir
		if [[ $mounted ]]; then
		  `which fusermount` -u ${servconf[2]}
		  log "Unmounted ${servconf[2]}"
		  # and unset it
		  unset mounted
	  fi
	done
}

# test_conf_dir ( host )
# Test if the needed config files exist
function test_conf_dir(){
  if [ ! -f ${CONF_DIR}/$1/globbing.conf ] || [ ! -f ${CONF_DIR}/$1/host.conf ]; then
    log "Missing configuration files for host ${1}. Aborting"
    exit 1
  fi
  
  return 0
}

# dest_dir ( string name )
# Test if backup destination directory exists and if not
#+create it.
function dest_dir() {
	local dir=${BACKUP_DIR}/${1}
	
	if [ -d $dir ]; then
		if [ $VERBOSE -eq 1 ]; then
			echo "> Backup directory for host exists" | tee -a $LOG
		fi
	else
		if [ $VERBOSE -eq 1 ]; then
			echo "> Backup directory for host does not exists; creating..." | tee -a $LOG
		fi
		
		mkdir $dir
		
		if [ -d $dir ]; then
			if [ $VERBOSE -eq 1 ]; then
				echo "> Created: "$dir | tee -a $LOG
			fi
		else
			echo "> FAILED! Backup ABORTED ( err: "$?" )" | tee -a $LOG
			exit $?
		fi
	fi
	
	return 0
}

# delay ( int time, bool stdout )
function backup_delay() {
	local delay_time=$1
	local stdout=$2
	
	for i in `seq $delay_time -1 1`
	do
		if [ $stdout -eq 1 ]; then
			echo -e -n "."
		fi
		sleep 1
	done
	
	if [ $stdout -eq 1 ]; then
		echo -e "\n"
	fi
}

# mount_sshfs ( user@host:dir mountpoint )
# This function will be valid only inside backup() function
#+due to use of certain variables setted there...
function mount_sshfs(){
  if ! ${servconf[0]}; then
    if ${servconf[3]}; then
      if [[ ! `which sshfs` ]]; then
        log "FATAL: sshfs is not installed on the system. Aborting... \n try apt-get install sshfs" 1
        return 1
      fi
      if [[ ! -d ${servconf[2]} ]]; then mkdir ${servconf[2]}; fi
      `which sshfs` ${servconf[1]}@${host}:${servconf[4]} ${servconf[2]}
      
      if [[ $? != 0 ]]; then
        log "FATAL: mount of the remote filesystem went bad; problem probably genereted remotly. Aborting"
        return 1
      fi
      mountpoint ${servconf[2]} #double control of the mount is paranoic?
      if [[ $? != 0 ]]; then
        log "FATAL: mount of the remote filesystem went bad; problem probably genereted remotly. Aborting"
        return 1
      else
        # At the end of the backup process will be a pleasure to have a quick way to verify
        #+if the dir is alredy mounted to unmount it before process another host/dir.
        #+Only to minimize risks that someone could have access to the remote files from the backup server
        #+and potentially put the word END on clients data... >_>
        mounted=true
      fi
    fi
  fi
  return 0
}

